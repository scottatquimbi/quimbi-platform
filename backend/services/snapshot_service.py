"""
Customer Profile Snapshot Service

Handles creation, storage, and retrieval of temporal customer snapshots.
Enables behavioral drift tracking without modifying existing clustering logic.

Key Features:
- Configurable snapshot intervals (daily, weekly, monthly, quarterly, yearly)
- Automatic retention policy enforcement
- Non-intrusive (doesn't modify customer_profiles table)
- Feature-flagged (can be disabled per tenant)
"""

import os
from datetime import datetime, timedelta, date
from typing import List, Optional, Dict, Any, Tuple
from dataclasses import dataclass
from enum import Enum
import logging
from uuid import UUID

from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession

logger = logging.getLogger(__name__)


class SnapshotType(str, Enum):
    """Snapshot interval types with retention policies"""
    DAILY = "daily"         # Retain for 7 days
    WEEKLY = "weekly"       # Retain for 60 days
    MONTHLY = "monthly"     # Retain for 1 year
    QUARTERLY = "quarterly" # Retain for 2 years
    YEARLY = "yearly"       # Retain for 5 years


@dataclass
class SnapshotConfig:
    """Configuration for snapshot intervals and retention"""
    # Retention policies (how long to keep snapshots)
    daily_retention_days: int = 7
    weekly_retention_days: int = 60
    monthly_retention_days: int = 365
    quarterly_retention_years: int = 2
    yearly_retention_years: int = 5

    # Feature flags
    enabled: bool = True
    store_behavioral_features: bool = True
    store_ml_predictions: bool = True

    @classmethod
    def from_env(cls) -> "SnapshotConfig":
        """Load configuration from environment variables"""
        return cls(
            enabled=os.getenv("ENABLE_TEMPORAL_SNAPSHOTS", "false").lower() == "true",
            store_behavioral_features=os.getenv("SNAPSHOT_STORE_FEATURES", "true").lower() == "true",
            store_ml_predictions=os.getenv("SNAPSHOT_STORE_ML", "true").lower() == "true",
            daily_retention_days=int(os.getenv("SNAPSHOT_DAILY_RETENTION", "7")),
            weekly_retention_days=int(os.getenv("SNAPSHOT_WEEKLY_RETENTION", "60")),
            monthly_retention_days=int(os.getenv("SNAPSHOT_MONTHLY_RETENTION", "365")),
        )


@dataclass
class CustomerSnapshot:
    """Customer profile snapshot at a point in time"""
    snapshot_id: Optional[UUID]
    customer_id: int
    store_id: str
    snapshot_date: date
    snapshot_type: SnapshotType

    # Profile data
    archetype_id: Optional[UUID]
    archetype_level: Optional[int]
    archetype_name: Optional[str]
    dominant_segments: Dict[str, str]      # {axis: segment_name}
    fuzzy_memberships: Dict[str, Dict]     # {axis: {segment: score}}
    behavioral_features: Optional[Dict]     # Raw features per axis

    # ML predictions
    churn_risk_score: Optional[float]
    churn_risk_level: Optional[str]
    predicted_ltv: Optional[float]

    # Context
    orders_at_snapshot: int
    total_value_at_snapshot: float
    days_since_first_order: int
    tenure_months: float

    created_at: Optional[datetime] = None
    data_version: str = "v1.0"


class CustomerSnapshotService:
    """Service for managing customer profile snapshots"""

    def __init__(self, db_session: AsyncSession, config: Optional[SnapshotConfig] = None):
        self.db = db_session
        self.config = config or SnapshotConfig.from_env()

    async def create_snapshot(
        self,
        customer_id: int,
        store_id: str,
        snapshot_type: SnapshotType,
        snapshot_date: Optional[date] = None
    ) -> Optional[CustomerSnapshot]:
        """
        Create a snapshot of customer's current profile.

        Args:
            customer_id: Customer ID to snapshot
            store_id: Store/tenant identifier
            snapshot_type: Type of snapshot (daily, weekly, etc.)
            snapshot_date: Date of snapshot (defaults to today)

        Returns:
            CustomerSnapshot object if successful, None if disabled or customer not found
        """
        if not self.config.enabled:
            logger.debug(f"Snapshots disabled, skipping snapshot for customer {customer_id}")
            return None

        snapshot_date = snapshot_date or date.today()

        try:
            # Fetch current customer profile
            profile = await self._fetch_customer_profile(customer_id, store_id)
            if not profile:
                logger.warning(f"Customer {customer_id} not found, cannot create snapshot")
                return None

            # Build snapshot object
            snapshot = CustomerSnapshot(
                snapshot_id=None,  # Will be generated by DB
                customer_id=customer_id,
                store_id=store_id,
                snapshot_date=snapshot_date,
                snapshot_type=snapshot_type,
                archetype_id=profile.get("archetype_id"),
                archetype_level=profile.get("archetype_level"),
                archetype_name=profile.get("archetype_name"),
                dominant_segments=profile.get("dominant_segments", {}),
                fuzzy_memberships=profile.get("fuzzy_memberships", {}),
                behavioral_features=profile.get("behavioral_features") if self.config.store_behavioral_features else None,
                churn_risk_score=profile.get("churn_risk_score") if self.config.store_ml_predictions else None,
                churn_risk_level=profile.get("churn_risk_level") if self.config.store_ml_predictions else None,
                predicted_ltv=profile.get("predicted_ltv") if self.config.store_ml_predictions else None,
                orders_at_snapshot=profile.get("total_orders", 0),
                total_value_at_snapshot=profile.get("total_value", 0.0),
                days_since_first_order=profile.get("days_since_first_order", 0),
                tenure_months=profile.get("tenure_months", 0.0),
            )

            # Insert snapshot into database
            await self._insert_snapshot(snapshot)

            logger.info(f"✅ Created {snapshot_type} snapshot for customer {customer_id} ({snapshot_date})")
            return snapshot

        except Exception as e:
            logger.error(f"Failed to create snapshot for customer {customer_id}: {e}")
            return None

    async def _fetch_customer_profile(self, customer_id: int, store_id: str) -> Optional[Dict[str, Any]]:
        """Fetch current customer profile from customer_profiles table"""
        query = text("""
            SELECT
                customer_id,
                archetype_id,
                archetype_level,
                archetype_name,
                dominant_segments,
                fuzzy_memberships,
                behavioral_traits,
                churn_risk_score,
                churn_risk_level,
                predicted_ltv,
                total_orders,
                total_value,
                days_since_first_order,
                tenure_months
            FROM platform.customer_profiles
            WHERE customer_id = :customer_id
            AND store_id = :store_id
        """)

        result = await self.db.execute(query, {"customer_id": customer_id, "store_id": store_id})
        row = result.fetchone()

        if not row:
            return None

        return {
            "archetype_id": row[1],
            "archetype_level": row[2],
            "archetype_name": row[3],
            "dominant_segments": row[4] or {},
            "fuzzy_memberships": row[5] or {},
            "behavioral_features": row[6] or {},  # behavioral_traits
            "churn_risk_score": row[7],
            "churn_risk_level": row[8],
            "predicted_ltv": row[9],
            "total_orders": row[10],
            "total_value": float(row[11]) if row[11] else 0.0,
            "days_since_first_order": row[12],
            "tenure_months": row[13],
        }

    async def _insert_snapshot(self, snapshot: CustomerSnapshot) -> None:
        """Insert snapshot into database"""
        query = text("""
            INSERT INTO platform.customer_profile_snapshots (
                customer_id, store_id, snapshot_date, snapshot_type,
                archetype_id, archetype_level, archetype_name,
                dominant_segments, fuzzy_memberships, behavioral_features,
                churn_risk_score, churn_risk_level, predicted_ltv,
                orders_at_snapshot, total_value_at_snapshot,
                days_since_first_order, tenure_months,
                data_version
            ) VALUES (
                :customer_id, :store_id, :snapshot_date, :snapshot_type,
                :archetype_id, :archetype_level, :archetype_name,
                :dominant_segments, :fuzzy_memberships, :behavioral_features,
                :churn_risk_score, :churn_risk_level, :predicted_ltv,
                :orders_at_snapshot, :total_value_at_snapshot,
                :days_since_first_order, :tenure_months,
                :data_version
            )
            ON CONFLICT (customer_id, snapshot_date, snapshot_type)
            DO UPDATE SET
                archetype_id = EXCLUDED.archetype_id,
                dominant_segments = EXCLUDED.dominant_segments,
                fuzzy_memberships = EXCLUDED.fuzzy_memberships,
                churn_risk_score = EXCLUDED.churn_risk_score,
                predicted_ltv = EXCLUDED.predicted_ltv
        """)

        await self.db.execute(query, {
            "customer_id": snapshot.customer_id,
            "store_id": snapshot.store_id,
            "snapshot_date": snapshot.snapshot_date,
            "snapshot_type": snapshot.snapshot_type.value,
            "archetype_id": snapshot.archetype_id,
            "archetype_level": snapshot.archetype_level,
            "archetype_name": snapshot.archetype_name,
            "dominant_segments": snapshot.dominant_segments,
            "fuzzy_memberships": snapshot.fuzzy_memberships,
            "behavioral_features": snapshot.behavioral_features,
            "churn_risk_score": snapshot.churn_risk_score,
            "churn_risk_level": snapshot.churn_risk_level,
            "predicted_ltv": snapshot.predicted_ltv,
            "orders_at_snapshot": snapshot.orders_at_snapshot,
            "total_value_at_snapshot": snapshot.total_value_at_snapshot,
            "days_since_first_order": snapshot.days_since_first_order,
            "tenure_months": snapshot.tenure_months,
            "data_version": snapshot.data_version,
        })

        await self.db.commit()

    async def get_customer_snapshots(
        self,
        customer_id: int,
        store_id: str,
        start_date: Optional[date] = None,
        end_date: Optional[date] = None,
        snapshot_type: Optional[SnapshotType] = None,
        limit: int = 100
    ) -> List[CustomerSnapshot]:
        """
        Retrieve snapshots for a customer.

        Args:
            customer_id: Customer ID
            store_id: Store identifier
            start_date: Filter snapshots from this date
            end_date: Filter snapshots until this date
            snapshot_type: Filter by snapshot type
            limit: Maximum snapshots to return

        Returns:
            List of CustomerSnapshot objects, ordered by date DESC
        """
        where_clauses = ["customer_id = :customer_id", "store_id = :store_id"]
        params = {"customer_id": customer_id, "store_id": store_id, "limit": limit}

        if start_date:
            where_clauses.append("snapshot_date >= :start_date")
            params["start_date"] = start_date

        if end_date:
            where_clauses.append("snapshot_date <= :end_date")
            params["end_date"] = end_date

        if snapshot_type:
            where_clauses.append("snapshot_type = :snapshot_type")
            params["snapshot_type"] = snapshot_type.value

        query = text(f"""
            SELECT
                snapshot_id, customer_id, store_id, snapshot_date, snapshot_type,
                archetype_id, archetype_level, archetype_name,
                dominant_segments, fuzzy_memberships, behavioral_features,
                churn_risk_score, churn_risk_level, predicted_ltv,
                orders_at_snapshot, total_value_at_snapshot,
                days_since_first_order, tenure_months,
                created_at, data_version
            FROM platform.customer_profile_snapshots
            WHERE {" AND ".join(where_clauses)}
            ORDER BY snapshot_date DESC
            LIMIT :limit
        """)

        result = await self.db.execute(query, params)
        rows = result.fetchall()

        snapshots = []
        for row in rows:
            snapshots.append(CustomerSnapshot(
                snapshot_id=row[0],
                customer_id=row[1],
                store_id=row[2],
                snapshot_date=row[3],
                snapshot_type=SnapshotType(row[4]),
                archetype_id=row[5],
                archetype_level=row[6],
                archetype_name=row[7],
                dominant_segments=row[8] or {},
                fuzzy_memberships=row[9] or {},
                behavioral_features=row[10],
                churn_risk_score=row[11],
                churn_risk_level=row[12],
                predicted_ltv=row[13],
                orders_at_snapshot=row[14],
                total_value_at_snapshot=float(row[15]) if row[15] else 0.0,
                days_since_first_order=row[16],
                tenure_months=row[17],
                created_at=row[18],
                data_version=row[19],
            ))

        return snapshots

    async def cleanup_old_snapshots(self, store_id: str) -> Dict[SnapshotType, int]:
        """
        Delete snapshots older than retention policy.

        Returns:
            Dictionary of {snapshot_type: rows_deleted}
        """
        if not self.config.enabled:
            return {}

        today = date.today()
        deleted_counts = {}

        # Define retention policies
        retention_policies = {
            SnapshotType.DAILY: timedelta(days=self.config.daily_retention_days),
            SnapshotType.WEEKLY: timedelta(days=self.config.weekly_retention_days),
            SnapshotType.MONTHLY: timedelta(days=self.config.monthly_retention_days),
            SnapshotType.QUARTERLY: timedelta(days=self.config.quarterly_retention_years * 365),
            SnapshotType.YEARLY: timedelta(days=self.config.yearly_retention_years * 365),
        }

        for snapshot_type, retention_delta in retention_policies.items():
            cutoff_date = today - retention_delta

            query = text("""
                DELETE FROM platform.customer_profile_snapshots
                WHERE store_id = :store_id
                AND snapshot_type = :snapshot_type
                AND snapshot_date < :cutoff_date
            """)

            result = await self.db.execute(query, {
                "store_id": store_id,
                "snapshot_type": snapshot_type.value,
                "cutoff_date": cutoff_date,
            })

            deleted_count = result.rowcount
            deleted_counts[snapshot_type] = deleted_count

            if deleted_count > 0:
                logger.info(f"Deleted {deleted_count} old {snapshot_type} snapshots (before {cutoff_date})")

        await self.db.commit()
        return deleted_counts

    async def create_snapshots_for_all_customers(
        self,
        store_id: str,
        snapshot_type: SnapshotType,
        snapshot_date: Optional[date] = None
    ) -> Tuple[int, int]:
        """
        Create snapshots for all customers in a store.

        Args:
            store_id: Store identifier
            snapshot_type: Type of snapshot to create
            snapshot_date: Date for snapshots (defaults to today)

        Returns:
            Tuple of (successful_count, failed_count)
        """
        if not self.config.enabled:
            logger.debug("Snapshots disabled, skipping batch creation")
            return (0, 0)

        snapshot_date = snapshot_date or date.today()

        # Get all customer IDs for this store
        query = text("""
            SELECT customer_id
            FROM platform.customer_profiles
            WHERE store_id = :store_id
        """)

        result = await self.db.execute(query, {"store_id": store_id})
        customer_ids = [row[0] for row in result.fetchall()]

        logger.info(f"Creating {snapshot_type} snapshots for {len(customer_ids)} customers in {store_id}...")

        successful = 0
        failed = 0

        for customer_id in customer_ids:
            snapshot = await self.create_snapshot(customer_id, store_id, snapshot_type, snapshot_date)
            if snapshot:
                successful += 1
            else:
                failed += 1

        logger.info(f"✅ Batch snapshot complete: {successful} successful, {failed} failed")
        return (successful, failed)


# Helper function for determining which snapshot to create
def determine_snapshot_type(current_date: date) -> Optional[SnapshotType]:
    """
    Determine which type of snapshot should be created for a given date.

    Returns:
        SnapshotType if a snapshot should be created, None otherwise

    Logic:
    - Daily: Every day
    - Weekly: Every Sunday
    - Monthly: 1st of each month
    - Quarterly: 1st of Jan, Apr, Jul, Oct
    - Yearly: Jan 1st
    """
    # Yearly (highest priority)
    if current_date.month == 1 and current_date.day == 1:
        return SnapshotType.YEARLY

    # Quarterly
    if current_date.day == 1 and current_date.month in [1, 4, 7, 10]:
        return SnapshotType.QUARTERLY

    # Monthly
    if current_date.day == 1:
        return SnapshotType.MONTHLY

    # Weekly (Sunday = 6)
    if current_date.weekday() == 6:
        return SnapshotType.WEEKLY

    # Daily (always)
    return SnapshotType.DAILY
